<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>テトリス</title>
  <style>
      body {
        background: #ddf5ff;
      }
      #container {
        margin: 0 auto;
      }
    </style>
</head>
<body onload="init()">
    <div id="container">
      <canvas id="cvs"></canvas>
    </div>
    <script>
    //ブロック1マスの大きさ
    const blockSize = 30;
    //ボードサイズ
    const boardRow = 20;
    const boardCol = 10;
    //キャンバスの取得
    const cvs = document.getElementById("cvs");
    //2dコンテキストを取得
    const ctx=cvs.getContext("2d");
    //キャンバスサイズ
    const canvasW = blockSize * boardCol;//300
    const canvasH = blockSize * boardRow;//600
    cvs.width = canvasW;
    cvs.height = canvasH;
    //コンテナの設定
    const container = document.getElementById("container");
    container.style.width = canvasW + 'px';

     //tetの1辺の大きさ
    const tetSize=4;
      //T型のtet
     let tet= [
            [0, 0, 0, 0],
            [0, 1, 0, 0],
            [1, 1, 1, 0],
            [0, 0, 0, 0],
          ];

    //テトリミノのオフセット量(何マス分ずれているか)
    let offsetX = 0;
    let offsetY = 0;

    //ボード本体
    const board = [];

    //描画処理
    const draw=()=>{
      //塗りに黒を設定
      ctx.fillStyle = '#000';
      //キャンバスを塗りつぶす
      ctx.fillRect(0, 0, canvasW, canvasH);

      //塗りに赤を設定
      //ctx.fillStyle="#f00";
      //x座標150,y座標150の場所に幅30,縦30の四角を描画
      //ctx.fillRect(150,150,blockSize,blockSize);

     //ボードに存在しているブロックを塗る
       for (let y = 0; y < boardRow; y++) {
         for (let x = 0; x < boardCol; x++) {
           if (board[y][x]) {
             drawBlock(x, y);
           }
         }
       }

     //テトリミノの描画
     for (let y = 0; y < tetSize; y++) {
          for (let x = 0; x < tetSize; x++) {
            if (tet[y][x]) {
            /*
            下でメソッド化したため
              ctx.fillRect(
                (offsetX+x)*blockSize ,//盤面上の場所
                (offsetY+y)*blockSize ,
                blockSize,
                blockSize);
             */

                drawBlock(offsetX+x,offsetY+y);

            }
          }
        }
    }

    //ブロック一つを描画する
    const drawBlock = (x, y) => {
        let px = x * blockSize;
        let py = y * blockSize;
        //塗りを設定
        ctx.fillStyle = '#f00';
        ctx.fillRect(px, py, blockSize, blockSize);
        //線を設定
        ctx.strokeStyle = 'black';
        //線を描画
        ctx.strokeRect(px, py, blockSize, blockSize);
      };

    //指定された方向に移動できるか？(x移動量,y移動量)
    const canMove = (dx, dy) => {
        for (let y = 0; y < tetSize; y++) {
          for (let x = 0; x < tetSize; x++) {
            //その場所にブロックがあれば
            if (tet[y][x]) {
              //ボード座標に変換
              let nx = offsetX + x + dx;
              let ny = offsetY + y + dy;
              if (
                //調査する座標がボード外だったらできない
                ny < 0 ||
                nx < 0 ||
                ny >= boardRow ||
                nx >= boardCol ||
                //移動したいボード上の場所にすでに存在してたらできない
                board[ny][nx]
              ) {
                //移動できない
                return false;
              }
            }
          }
        }
        //移動できる
        return true;
      };



    document.onkeydown = (e) =>{
        switch (e.keyCode) {
          case 37: //左
            if(canMove(-1,0)) offsetX--;
            break;
          case 38: //上
            if(canMove(0,-1)) offsetY--;
            break;
          case 39: //右
            if(canMove(1,0)) offsetX++;
            break;
          case 40: //下
            if(canMove(0,1)) offsetY++;
            break;
        }
        draw();
    };

    //初期化処理
    const init=()=>{
        //まずボード20*10を0埋め
        for (let y = 0; y < boardRow; y++) {
          board[y] = [];
          for (let x = 0; x < boardCol; x++) {
            board[y][x] = 0;
          }
        }
        //テスト用
        board[3][5]=1;

      draw();
    }
    </script> 
</body>
</html>